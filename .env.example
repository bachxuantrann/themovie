// ========== 1. ENHANCED MOVIE RELATIONSHIP CONTROLLER ==========

@RestController
@RequestMapping("/api")
@Slf4j
@Validated
public class MovieRelationshipController {

    private final MovieRelationshipService relationshipService;

    public MovieRelationshipController(MovieRelationshipService relationshipService) {
        this.relationshipService = relationshipService;
    }

    // Universal endpoint cho tất cả relationship types
    @GetMapping("/movies/{movieId}/relationships/{type}")
    public ResponseEntity<ApiResponse<List<?>>> getMovieRelationships(
            @PathVariable @Min(1) Long movieId,
            @PathVariable @Pattern(regexp = "^(genres|countries|languages|companies|cast|crew)$", 
                                 message = "Invalid relationship type") String type,
            @RequestParam(defaultValue = "0") @Min(0) int page,
            @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size) {
        
        log.info("Getting {} relationships for movie {}", type, movieId);
        List<?> relationships = relationshipService.getRelationships(movieId, type, page, size);
        return ResponseEntity.ok(ApiResponse.success(relationships));
    }

    // Universal endpoint để thêm relationships
    @PostMapping("/movies/{movieId}/relationships/{type}")
    public ResponseEntity<ApiResponse<String>> addMovieRelationships(
            @PathVariable @Min(1) Long movieId,
            @PathVariable @Pattern(regexp = "^(genres|countries|languages|companies)$") String type,
            @RequestBody @Valid @NotEmpty List<@Min(1) Long> entityIds) {
        
        log.info("Adding {} relationships to movie {}", type, movieId);
        relationshipService.addRelationships(movieId, type, entityIds);
        return ResponseEntity.ok(ApiResponse.success("Relationships added successfully"));
    }

    // Specific endpoint for cast/crew with additional data
    @PostMapping("/movies/{movieId}/relationships/cast")
    public ResponseEntity<ApiResponse<String>> addMovieCast(
            @PathVariable @Min(1) Long movieId,
            @RequestBody @Valid List<CastRequest> castRequests) {
        
        log.info("Adding cast to movie {}", movieId);
        relationshipService.addMovieCast(movieId, castRequests);
        return ResponseEntity.ok(ApiResponse.success("Cast added successfully"));
    }

    @PostMapping("/movies/{movieId}/relationships/crew")
    public ResponseEntity<ApiResponse<String>> addMovieCrew(
            @PathVariable @Min(1) Long movieId,
            @RequestBody @Valid List<CrewRequest> crewRequests) {
        
        log.info("Adding crew to movie {}", movieId);
        relationshipService.addMovieCrew(movieId, crewRequests);
        return ResponseEntity.ok(ApiResponse.success("Crew added successfully"));
    }

    // Universal endpoint để xóa relationship
    @DeleteMapping("/movies/{movieId}/relationships/{type}/{entityId}")
    public ResponseEntity<ApiResponse<String>> removeMovieRelationship(
            @PathVariable @Min(1) Long movieId,
            @PathVariable String type,
            @PathVariable @Min(1) Long entityId) {
        
        log.info("Removing {} relationship {} from movie {}", type, entityId, movieId);
        relationshipService.removeRelationship(movieId, type, entityId);
        return ResponseEntity.ok(ApiResponse.success("Relationship removed successfully"));
    }

    // Reverse lookup - Universal endpoint
    @GetMapping("/{entityType}/{entityId}/movies")
    public ResponseEntity<ApiResponse<Page<MovieDTO>>> getMoviesByEntity(
            @PathVariable @Pattern(regexp = "^(genres|countries|languages|companies|persons)$") String entityType,
            @PathVariable @Min(1) Long entityId,
            @RequestParam(defaultValue = "0") @Min(0) int page,
            @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size,
            @RequestParam(required = false) String job) {
        
        log.info("Getting movies for {} {}", entityType, entityId);
        Page<MovieDTO> movies = relationshipService.getMoviesByEntity(
            entityType, entityId, job, PageRequest.of(page, size));
        return ResponseEntity.ok(ApiResponse.success(movies));
    }

    // Bulk operations
    @PostMapping("/movies/{movieId}/relationships/{type}/bulk")
    public ResponseEntity<ApiResponse<String>> bulkAddRelationships(
            @PathVariable @Min(1) Long movieId,
            @PathVariable String type,
            @RequestBody @Valid BulkRelationshipRequest request) {
        
        log.info("Bulk adding {} relationships to movie {}", type, movieId);
        relationshipService.bulkAddRelationships(movieId, type, request);
        return ResponseEntity.ok(ApiResponse.success("Bulk relationships added successfully"));
    }

    @DeleteMapping("/movies/{movieId}/relationships/{type}/bulk")
    public ResponseEntity<ApiResponse<String>> bulkRemoveRelationships(
            @PathVariable @Min(1) Long movieId,
            @PathVariable String type,
            @RequestBody @Valid List<@Min(1) Long> entityIds) {
        
        log.info("Bulk removing {} relationships from movie {}", type, movieId);
        relationshipService.bulkRemoveRelationships(movieId, type, entityIds);
        return ResponseEntity.ok(ApiResponse.success("Bulk relationships removed successfully"));
    }

    // Get relationship statistics
    @GetMapping("/movies/{movieId}/relationships/stats")
    public ResponseEntity<ApiResponse<RelationshipStatsDTO>> getRelationshipStats(
            @PathVariable @Min(1) Long movieId) {
        
        RelationshipStatsDTO stats = relationshipService.getRelationshipStats(movieId);
        return ResponseEntity.ok(ApiResponse.success(stats));
    }
}

// ========== 2. ENHANCED RELATIONSHIP SERVICE ==========

@Service
@Transactional
@Slf4j
@CacheConfig(cacheNames = "movieRelationships")
public class MovieRelationshipService {

    private final MovieRepository movieRepository;
    private final RelationshipRepositoryFactory repositoryFactory;
    private final RelationshipMapperFactory mapperFactory;
    private final ApplicationEventPublisher eventPublisher;

    // Constructor injection (recommended over @Autowired)
    public MovieRelationshipService(MovieRepository movieRepository,
                                  RelationshipRepositoryFactory repositoryFactory,
                                  RelationshipMapperFactory mapperFactory,
                                  ApplicationEventPublisher eventPublisher) {
        this.movieRepository = movieRepository;
        this.repositoryFactory = repositoryFactory;
        this.mapperFactory = mapperFactory;
        this.eventPublisher = eventPublisher;
    }

    // Enhanced enum with more metadata
    public enum RelationshipType {
        GENRES("genres", "movie_genres", "genre_id", GenreDTO.class, true),
        COUNTRIES("countries", "movie_countries", "country_id", CountryDTO.class, true),
        LANGUAGES("languages", "movie_languages", "language_id", LanguageDTO.class, true),
        COMPANIES("companies", "movie_companies", "company_id", CompanyDTO.class, true),
        CAST("cast", "movie_casts", "person_id", CastDTO.class, false),
        CREW("crew", "movie_casts", "person_id", CrewDTO.class, false);

        private final String type;
        private final String tableName;
        private final String entityIdColumn;
        private final Class<?> dtoClass;
        private final boolean supportsBulkAdd;

        RelationshipType(String type, String tableName, String entityIdColumn, Class<?> dtoClass, boolean supportsBulkAdd) {
            this.type = type;
            this.tableName = tableName;
            this.entityIdColumn = entityIdColumn;
            this.dtoClass = dtoClass;
            this.supportsBulkAdd = supportsBulkAdd;
        }

        public static RelationshipType fromString(String type) {
            return Arrays.stream(values())
                    .filter(rt -> rt.type.equals(type))
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException("Invalid relationship type: " + type));
        }

        // Getters
        public String getType() { return type; }
        public String getTableName() { return tableName; }
        public String getEntityIdColumn() { return entityIdColumn; }
        public Class<?> getDtoClass() { return dtoClass; }
        public boolean isSupportsBulkAdd() { return supportsBulkAdd; }
    }

    @Cacheable(key = "#movieId + '_' + #type + '_' + #page + '_' + #size")
    public List<?> getRelationships(Long movieId, String type, int page, int size) {
        RelationshipType relationshipType = RelationshipType.fromString(type);
        
        validateMovieExists(movieId);
        
        log.debug("Fetching {} relationships for movie {} (page: {}, size: {})", type, movieId, page, size);
        
        return switch (relationshipType) {
            case GENRES -> getMovieGenres(movieId, page, size);
            case COUNTRIES -> getMovieCountries(movieId, page, size);
            case LANGUAGES -> getMovieLanguages(movieId, page, size);
            case COMPANIES -> getMovieCompanies(movieId, page, size);
            case CAST -> getMovieCast(movieId, page, size);
            case CREW -> getMovieCrew(movieId, page, size);
        };
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public void addRelationships(Long movieId, String type, List<Long> entityIds) {
        RelationshipType relationshipType = RelationshipType.fromString(type);
        validateMovieExists(movieId);
        
        if (!relationshipType.isSupportsBulkAdd()) {
            throw new UnsupportedOperationException(
                "Use specific endpoint for " + type + " with additional data");
        }
        
        // Remove duplicates and validate entity IDs
        List<Long> uniqueEntityIds = entityIds.stream()
            .distinct()
            .collect(Collectors.toList());
        
        validateEntityIds(relationshipType, uniqueEntityIds);
        
        switch (relationshipType) {
            case GENRES -> addMovieGenres(movieId, uniqueEntityIds);
            case COUNTRIES -> addMovieCountries(movieId, uniqueEntityIds);
            case LANGUAGES -> addMovieLanguages(movieId, uniqueEntityIds);
            case COMPANIES -> addMovieCompanies(movieId, uniqueEntityIds);
        }
        
        // Publish event for cache invalidation or other side effects
        eventPublisher.publishEvent(new RelationshipChangedEvent(movieId, type, "ADD"));
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public void removeRelationship(Long movieId, String type, Long entityId) {
        RelationshipType relationshipType = RelationshipType.fromString(type);
        validateMovieExists(movieId);

        switch (relationshipType) {
            case GENRES -> removeMovieGenre(movieId, entityId);
            case COUNTRIES -> removeMovieCountry(movieId, entityId);
            case LANGUAGES -> removeMovieLanguage(movieId, entityId);
            case COMPANIES -> removeMovieCompany(movieId, entityId);
            case CAST, CREW -> removeMovieCast(movieId, entityId);
        }
        
        eventPublisher.publishEvent(new RelationshipChangedEvent(movieId, type, "REMOVE"));
    }

    // Specialized methods for cast and crew
    @Transactional
    @CacheEvict(allEntries = true)
    public void addMovieCast(Long movieId, List<CastRequest> castRequests) {
        validateMovieExists(movieId);
        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieCast> casts = castRequests.stream()
            .map(request -> {
                validatePersonExists(request.getPersonId());
                return MovieCast.builder()
                    .movie(movie)
                    .person(Person.builder().id(request.getPersonId()).build())
                    .characterName(request.getCharacterName())
                    .orderIndex(request.getOrderIndex())
                    .job("actor")
                    .build();
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieCastRepository().saveAll(casts);
        eventPublisher.publishEvent(new RelationshipChangedEvent(movieId, "cast", "ADD"));
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public void addMovieCrew(Long movieId, List<CrewRequest> crewRequests) {
        validateMovieExists(movieId);
        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieCast> crew = crewRequests.stream()
            .map(request -> {
                validatePersonExists(request.getPersonId());
                return MovieCast.builder()
                    .movie(movie)
                    .person(Person.builder().id(request.getPersonId()).build())
                    .job(request.getJob())
                    .build();
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieCastRepository().saveAll(crew);
        eventPublisher.publishEvent(new RelationshipChangedEvent(movieId, "crew", "ADD"));
    }

    // Bulk operations
    @Transactional
    @CacheEvict(allEntries = true)
    public void bulkAddRelationships(Long movieId, String type, BulkRelationshipRequest request) {
        validateMovieExists(movieId);
        
        // Remove existing relationships if replace mode
        if (request.isReplaceMode()) {
            clearMovieRelationships(movieId, type);
        }
        
        if (!request.getEntityIds().isEmpty()) {
            addRelationships(movieId, type, request.getEntityIds());
        }
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public void bulkRemoveRelationships(Long movieId, String type, List<Long> entityIds) {
        validateMovieExists(movieId);
        
        entityIds.forEach(entityId -> removeRelationship(movieId, type, entityId));
    }

    // Get relationship statistics
    public RelationshipStatsDTO getRelationshipStats(Long movieId) {
        validateMovieExists(movieId);
        
        return RelationshipStatsDTO.builder()
            .genreCount(repositoryFactory.getMovieGenreRepository().countByMovieId(movieId))
            .countryCount(repositoryFactory.getMovieCountryRepository().countByMovieId(movieId))
            .languageCount(repositoryFactory.getMovieLanguageRepository().countByMovieId(movieId))
            .companyCount(repositoryFactory.getMovieCompanyRepository().countByMovieId(movieId))
            .castCount(repositoryFactory.getMovieCastRepository().countByMovieIdAndJob(movieId, "actor"))
            .crewCount(repositoryFactory.getMovieCastRepository().countByMovieIdAndJobNot(movieId, "actor"))
            .build();
    }

    // Reverse lookup with caching
    @Cacheable(key = "#entityType + '_' + #entityId + '_' + #job + '_' + #pageable.pageNumber + '_' + #pageable.pageSize")
    public Page<MovieDTO> getMoviesByEntity(String entityType, Long entityId, String job, Pageable pageable) {
        return switch (entityType.toLowerCase()) {
            case "genres" -> movieRepository.findByGenreId(entityId, pageable).map(this::convertToMovieDTO);
            case "countries" -> movieRepository.findByCountryId(entityId, pageable).map(this::convertToMovieDTO);
            case "languages" -> movieRepository.findByLanguageId(entityId, pageable).map(this::convertToMovieDTO);
            case "companies" -> movieRepository.findByCompanyId(entityId, pageable).map(this::convertToMovieDTO);
            case "persons" -> {
                if (StringUtils.hasText(job)) {
                    yield movieRepository.findByPersonIdAndJob(entityId, job, pageable).map(this::convertToMovieDTO);
                }
                yield movieRepository.findByPersonId(entityId, pageable).map(this::convertToMovieDTO);
            }
            default -> throw new IllegalArgumentException("Invalid entity type: " + entityType);
        };
    }

    // ========== PRIVATE HELPER METHODS ==========

    private List<GenreDTO> getMovieGenres(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return repositoryFactory.getMovieGenreRepository()
            .findGenresByMovieId(movieId, pageable)
            .stream()
            .map(genre -> new GenreDTO(genre.getId(), genre.getName()))
            .collect(Collectors.toList());
    }

    private List<CountryDTO> getMovieCountries(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return repositoryFactory.getMovieCountryRepository()
            .findCountriesByMovieId(movieId, pageable)
            .stream()
            .map(country -> new CountryDTO(country.getId(), country.getName(), country.getCountryCode()))
            .collect(Collectors.toList());
    }

    private List<LanguageDTO> getMovieLanguages(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return repositoryFactory.getMovieLanguageRepository()
            .findLanguagesByMovieId(movieId, pageable)
            .stream()
            .map(language -> new LanguageDTO(language.getId(), language.getName(), language.getLanguageCode()))
            .collect(Collectors.toList());
    }

    private List<CompanyDTO> getMovieCompanies(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return repositoryFactory.getMovieCompanyRepository()
            .findCompaniesByMovieId(movieId, pageable)
            .stream()
            .map(company -> new CompanyDTO(company.getId(), company.getName(), company.getLogoPath()))
            .collect(Collectors.toList());
    }

    private List<CastDTO> getMovieCast(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("orderIndex").ascending());
        return repositoryFactory.getMovieCastRepository()
            .findCastByMovieId(movieId, pageable)
            .stream()
            .map(cast -> CastDTO.builder()
                .id(cast.getId())
                .personId(cast.getPerson().getId())
                .name(cast.getPerson().getName())
                .profilePath(cast.getPerson().getProfilePath())
                .characterName(cast.getCharacterName())
                .orderIndex(cast.getOrderIndex())
                .build())
            .collect(Collectors.toList());
    }

    private List<CrewDTO> getMovieCrew(Long movieId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("job", "person.name"));
        return repositoryFactory.getMovieCastRepository()
            .findCrewByMovieId(movieId, pageable)
            .stream()
            .map(crew -> CrewDTO.builder()
                .id(crew.getId())
                .personId(crew.getPerson().getId())
                .name(crew.getPerson().getName())
                .profilePath(crew.getPerson().getProfilePath())
                .job(crew.getJob())
                .build())
            .collect(Collectors.toList());
    }

    // Optimized add methods with batch processing
    private void addMovieGenres(Long movieId, List<Long> genreIds) {
        // Check existing relationships to avoid duplicates
        Set<Long> existingGenreIds = repositoryFactory.getMovieGenreRepository()
            .findExistingGenreIdsByMovieId(movieId);
        
        List<Long> newGenreIds = genreIds.stream()
            .filter(id -> !existingGenreIds.contains(id))
            .collect(Collectors.toList());
            
        if (newGenreIds.isEmpty()) {
            return;
        }

        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieGenre> movieGenres = newGenreIds.stream()
            .map(genreId -> {
                validateGenreExists(genreId);
                return new MovieGenre(movie, Genre.builder().id(genreId).build());
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieGenreRepository().saveAll(movieGenres);
    }

    private void addMovieCountries(Long movieId, List<Long> countryIds) {
        Set<Long> existingCountryIds = repositoryFactory.getMovieCountryRepository()
            .findExistingCountryIdsByMovieId(movieId);
        
        List<Long> newCountryIds = countryIds.stream()
            .filter(id -> !existingCountryIds.contains(id))
            .collect(Collectors.toList());
            
        if (newCountryIds.isEmpty()) {
            return;
        }

        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieCountry> movieCountries = newCountryIds.stream()
            .map(countryId -> {
                validateCountryExists(countryId);
                return new MovieCountry(movie, Country.builder().id(countryId).build());
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieCountryRepository().saveAll(movieCountries);
    }

    private void addMovieLanguages(Long movieId, List<Long> languageIds) {
        Set<Long> existingLanguageIds = repositoryFactory.getMovieLanguageRepository()
            .findExistingLanguageIdsByMovieId(movieId);
        
        List<Long> newLanguageIds = languageIds.stream()
            .filter(id -> !existingLanguageIds.contains(id))
            .collect(Collectors.toList());
            
        if (newLanguageIds.isEmpty()) {
            return;
        }

        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieLanguage> movieLanguages = newLanguageIds.stream()
            .map(languageId -> {
                validateLanguageExists(languageId);
                return new MovieLanguage(movie, Language.builder().id(languageId).build());
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieLanguageRepository().saveAll(movieLanguages);
    }

    private void addMovieCompanies(Long movieId, List<Long> companyIds) {
        Set<Long> existingCompanyIds = repositoryFactory.getMovieCompanyRepository()
            .findExistingCompanyIdsByMovieId(movieId);
        
        List<Long> newCompanyIds = companyIds.stream()
            .filter(id -> !existingCompanyIds.contains(id))
            .collect(Collectors.toList());
            
        if (newCompanyIds.isEmpty()) {
            return;
        }

        Movie movie = movieRepository.getReferenceById(movieId);
        
        List<MovieCompany> movieCompanies = newCompanyIds.stream()
            .map(companyId -> {
                validateCompanyExists(companyId);
                return new MovieCompany(movie, Company.builder().id(companyId).build());
            })
            .collect(Collectors.toList());
            
        repositoryFactory.getMovieCompanyRepository().saveAll(movieCompanies);
    }

    // Remove methods
    private void removeMovieGenre(Long movieId, Long genreId) {
        repositoryFactory.getMovieGenreRepository().deleteByMovieIdAndGenreId(movieId, genreId);
    }

    private void removeMovieCountry(Long movieId, Long countryId) {
        repositoryFactory.getMovieCountryRepository().deleteByMovieIdAndCountryId(movieId, countryId);
    }

    private void removeMovieLanguage(Long movieId, Long languageId) {
        repositoryFactory.getMovieLanguageRepository().deleteByMovieIdAndLanguageId(movieId, languageId);
    }

    private void removeMovieCompany(Long movieId, Long companyId) {
        repositoryFactory.getMovieCompanyRepository().deleteByMovieIdAndCompanyId(movieId, companyId);
    }

    private void removeMovieCast(Long movieId, Long castId) {
        repositoryFactory.getMovieCastRepository().deleteByIdAndMovieId(castId, movieId);
    }

    private void clearMovieRelationships(Long movieId, String type) {
        RelationshipType relationshipType = RelationshipType.fromString(type);
        
        switch (relationshipType) {
            case GENRES -> repositoryFactory.getMovieGenreRepository().deleteByMovieId(movieId);
            case COUNTRIES -> repositoryFactory.getMovieCountryRepository().deleteByMovieId(movieId);
            case LANGUAGES -> repositoryFactory.getMovieLanguageRepository().deleteByMovieId(movieId);
            case COMPANIES -> repositoryFactory.getMovieCompanyRepository().deleteByMovieId(movieId);
            case CAST -> repositoryFactory.getMovieCastRepository().deleteByMovieIdAndJob(movieId, "actor");
            case CREW -> repositoryFactory.getMovieCastRepository().deleteByMovieIdAndJobNot(movieId, "actor");
        }
    }

    // Validation methods
    private void validateMovieExists(Long movieId) {
        if (!movieRepository.existsById(movieId)) {
            throw new ResourceNotFoundException("Movie not found with id: " + movieId);
        }
    }

    private void validateEntityIds(RelationshipType type, List<Long> entityIds) {
        switch (type) {
            case GENRES -> entityIds.forEach(this::validateGenreExists);
            case COUNTRIES -> entityIds.forEach(this::validateCountryExists);
            case LANGUAGES -> entityIds.forEach(this::validateLanguageExists);
            case COMPANIES -> entityIds.forEach(this::validateCompanyExists);
        }
    }

    private void validateGenreExists(Long genreId) {
        if (!repositoryFactory.getGenreRepository().existsById(genreId)) {
            throw new ResourceNotFoundException("Genre not found with id: " + genreId);
        }
    }

    private void validateCountryExists(Long countryId) {
        if (!repositoryFactory.getCountryRepository().existsById(countryId)) {
            throw new ResourceNotFoundException("Country not found with id: " + countryId);
        }
    }

    private void validateLanguageExists(Long languageId) {
        if (!repositoryFactory.getLanguageRepository().existsById(languageId)) {
            throw new ResourceNotFoundException("Language not found with id: " + languageId);
        }
    }

    private void validateCompanyExists(Long companyId) {
        if (!repositoryFactory.getCompanyRepository().existsById(companyId)) {
            throw new ResourceNotFoundException("Company not found with id: " + companyId);
        }
    }

    private void validatePersonExists(Long personId) {
        if (!repositoryFactory.getPersonRepository().existsById(personId)) {
            throw new ResourceNotFoundException("Person not found with id: " + personId);
        }
    }

    private MovieDTO convertToMovieDTO(Movie movie) {
        return MovieDTO.builder()
            .id(movie.getId())
            .title(movie.getTitle())
            .originalTitle(movie.getOriginalTitle())
            .overview(movie.getOverview())
            .releaseDate(movie.getReleaseDate())
            .posterPath(movie.getPosterPath())
            .backdropPath(movie.getBackdropPath())
            .voteAverage(movie.getVoteAverage())
            .voteCount(movie.getVoteCount())
            .runtime(movie.getRuntime())
            .build();
    }
}

// ========== 3. REPOSITORY FACTORY ==========

@Component
public class RelationshipRepositoryFactory {
    
    private final MovieGenreRepository movieGenreRepository;
    private final MovieCountryRepository movieCountryRepository;
    private final MovieLanguageRepository movieLanguageRepository;
    private final MovieCompanyRepository movieCompanyRepository;
    private final MovieCastRepository movieCastRepository;
    private final GenreRepository genreRepository;
    private final CountryRepository countryRepository;
    private final LanguageRepository languageRepository;
    private final CompanyRepository companyRepository;
    private final PersonRepository personRepository;

    // Constructor injection
    public RelationshipRepositoryFactory(
            MovieGenreRepository movieGenreRepository,
            MovieCountryRepository movieCountryRepository,
            MovieLanguageRepository movieLanguageRepository,
            MovieCompanyRepository movieCompanyRepository,
            MovieCastRepository movieCastRepository,
            GenreRepository genreRepository,
            CountryRepository countryRepository,
            LanguageRepository languageRepository,
            CompanyRepository companyRepository,
            PersonRepository personRepository) {
        
        this.movieGenreRepository = movieGenreRepository;
        this.movieCountryRepository = movieCountryRepository;
        this.movieLanguageRepository = movieLanguageRepository;
        this.movieCompanyRepository = movieCompanyRepository;
        this.movieCastRepository = movieCastRepository;
        this.genreRepository = genreRepository;
        this.countryRepository = countryRepository;
        this.languageRepository = languageRepository;
        this.companyRepository = companyRepository;
        this.personRepository = personRepository;
    }

    // Getters for all repositories
    public MovieGenreRepository getMovieGenreRepository() { return movieGenreRepository; }
    public MovieCountryRepository getMovieCountryRepository() { return movieCountryRepository; }
    public MovieLanguageRepository getMovieLanguageRepository() { return movieLanguageRepository; }
    public MovieCompanyRepository getMovieCompanyRepository() { return movieCompanyRepository; }
    public MovieCastRepository getMovieCastRepository() { return movieCastRepository; }
    public GenreRepository getGenreRepository() { return genreRepository; }
    public CountryRepository getCountryRepository() { return countryRepository; }
    public LanguageRepository getLanguageRepository() { return languageRepository; }
    public CompanyRepository getCompanyRepository() { return companyRepository; }
    public PersonRepository getPersonRepository() { return personRepository; }
}

// ========== 4. ENHANCED REPOSITORY INTERFACES ==========

// MovieRepository.java
public interface MovieRepository extends JpaRepository<Movie, Long> {
    
    @Query("SELECT m FROM Movie m JOIN MovieGenre mg ON m.id = mg.movie.id WHERE mg.genre.id = :genreId")
    Page<Movie> findByGenreId(@Param("genreId") Long genreId, Pageable pageable);
    
    @Query("SELECT m FROM Movie m JOIN MovieCountry mc ON m.id = mc.movie.id WHERE mc.country.id = :countryId")
    Page<Movie> findByCountryId(@Param("countryId") Long countryId, Pageable pageable);
    
    @Query("SELECT m FROM Movie m JOIN MovieLanguage ml ON m.id = ml.movie.id WHERE ml.language.id = :languageId")
    Page<Movie> findByLanguageId(@Param("languageId") Long languageId, Pageable pageable);
    
    @Query("SELECT m FROM Movie m JOIN MovieCompany mc ON m.id = mc.movie.id WHERE mc.company.id = :companyId")
    Page<Movie> findByCompanyId(@Param("companyId") Long companyId, Pageable pageable);
    
    @Query("SELECT m FROM Movie m JOIN MovieCast mc ON m.id = mc.movie.id WHERE mc.person.id = :personId")
    Page<Movie> findByPersonId(@Param("personId") Long personId, Pageable pageable);
    
    @Query("SELECT m FROM Movie m JOIN MovieCast mc ON m.id = mc.movie.id WHERE mc.person.id = :personId AND mc.job = :job")
    Page<Movie> findByPersonIdAndJob(@Param("personId") Long personId, @Param("job") String job, Pageable pageable);
}

// Enhanced MovieGenreRepository.java
public interface MovieGenreRepository extends JpaRepository<MovieGenre, Long> {
    
    @Query("SELECT mg.genre FROM MovieGenre mg WHERE mg.movie.id = :movieId ORDER BY mg.genre.name")
    List<Genre> findGenresByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT mg.genre.id FROM MovieGenre mg WHERE mg.movie.id = :movieId")
    Set<Long> findExistingGenreIdsByMovieId(@Param("movieId") Long movieId);
    
    @Modifying
    @Query("DELETE FROM MovieGenre mg WHERE mg.movie.id = :movieId AND mg.genre.id = :genreId")
    void deleteByMovieIdAndGenreId(@Param("movieId") Long movieId, @Param("genreId") Long genreId);
    
    @Modifying
    @Query("DELETE FROM MovieGenre mg WHERE mg.movie.id = :movieId")
    void deleteByMovieId(@Param("movieId") Long movieId);
    
    @Query("SELECT COUNT(mg) FROM MovieGenre mg WHERE mg.movie.id = :movieId")
    Long countByMovieId(@Param("movieId") Long movieId);
    
    boolean existsByMovieIdAndGenreId(Long movieId, Long genreId);
}

// Enhanced MovieCountryRepository.java
public interface MovieCountryRepository extends JpaRepository<MovieCountry, Long> {
    
    @Query("SELECT mc.country FROM MovieCountry mc WHERE mc.movie.id = :movieId ORDER BY mc.country.name")
    List<Country> findCountriesByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT mc.country.id FROM MovieCountry mc WHERE mc.movie.id = :movieId")
    Set<Long> findExistingCountryIdsByMovieId(@Param("movieId") Long movieId);
    
    @Modifying
    @Query("DELETE FROM MovieCountry mc WHERE mc.movie.id = :movieId AND mc.country.id = :countryId")
    void deleteByMovieIdAndCountryId(@Param("movieId") Long movieId, @Param("countryId") Long countryId);
    
    @Modifying
    @Query("DELETE FROM MovieCountry mc WHERE mc.movie.id = :movieId")
    void deleteByMovieId(@Param("movieId") Long movieId);
    
    @Query("SELECT COUNT(mc) FROM MovieCountry mc WHERE mc.movie.id = :movieId")
    Long countByMovieId(@Param("movieId") Long movieId);
    
    boolean existsByMovieIdAndCountryId(Long movieId, Long countryId);
}

// Enhanced MovieLanguageRepository.java
public interface MovieLanguageRepository extends JpaRepository<MovieLanguage, Long> {
    
    @Query("SELECT ml.language FROM MovieLanguage ml WHERE ml.movie.id = :movieId ORDER BY ml.language.name")
    List<Language> findLanguagesByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT ml.language.id FROM MovieLanguage ml WHERE ml.movie.id = :movieId")
    Set<Long> findExistingLanguageIdsByMovieId(@Param("movieId") Long movieId);
    
    @Modifying
    @Query("DELETE FROM MovieLanguage ml WHERE ml.movie.id = :movieId AND ml.language.id = :languageId")
    void deleteByMovieIdAndLanguageId(@Param("movieId") Long movieId, @Param("languageId") Long languageId);
    
    @Modifying
    @Query("DELETE FROM MovieLanguage ml WHERE ml.movie.id = :movieId")
    void deleteByMovieId(@Param("movieId") Long movieId);
    
    @Query("SELECT COUNT(ml) FROM MovieLanguage ml WHERE ml.movie.id = :movieId")
    Long countByMovieId(@Param("movieId") Long movieId);
    
    boolean existsByMovieIdAndLanguageId(Long movieId, Long languageId);
}

// Enhanced MovieCompanyRepository.java
public interface MovieCompanyRepository extends JpaRepository<MovieCompany, Long> {
    
    @Query("SELECT mc.company FROM MovieCompany mc WHERE mc.movie.id = :movieId ORDER BY mc.company.name")
    List<Company> findCompaniesByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT mc.company.id FROM MovieCompany mc WHERE mc.movie.id = :movieId")
    Set<Long> findExistingCompanyIdsByMovieId(@Param("movieId") Long movieId);
    
    @Modifying
    @Query("DELETE FROM MovieCompany mc WHERE mc.movie.id = :movieId AND mc.company.id = :companyId")
    void deleteByMovieIdAndCompanyId(@Param("movieId") Long movieId, @Param("companyId") Long companyId);
    
    @Modifying
    @Query("DELETE FROM MovieCompany mc WHERE mc.movie.id = :movieId")
    void deleteByMovieId(@Param("movieId") Long movieId);
    
    @Query("SELECT COUNT(mc) FROM MovieCompany mc WHERE mc.movie.id = :movieId")
    Long countByMovieId(@Param("movieId") Long movieId);
    
    boolean existsByMovieIdAndCompanyId(Long movieId, Long companyId);
}

// Enhanced MovieCastRepository.java
public interface MovieCastRepository extends JpaRepository<MovieCast, Long> {
    
    @Query("SELECT mc FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job = 'actor' ORDER BY mc.orderIndex ASC, mc.person.name ASC")
    List<MovieCast> findCastByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT mc FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job != 'actor' ORDER BY mc.job ASC, mc.person.name ASC")
    List<MovieCast> findCrewByMovieId(@Param("movieId") Long movieId, Pageable pageable);
    
    @Query("SELECT COUNT(mc) FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job = :job")
    Long countByMovieIdAndJob(@Param("movieId") Long movieId, @Param("job") String job);
    
    @Query("SELECT COUNT(mc) FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job != :job")
    Long countByMovieIdAndJobNot(@Param("movieId") Long movieId, @Param("job") String job);
    
    @Modifying
    @Query("DELETE FROM MovieCast mc WHERE mc.id = :castId AND mc.movie.id = :movieId")
    void deleteByIdAndMovieId(@Param("castId") Long castId, @Param("movieId") Long movieId);
    
    @Modifying
    @Query("DELETE FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job = :job")
    void deleteByMovieIdAndJob(@Param("movieId") Long movieId, @Param("job") String job);
    
    @Modifying
    @Query("DELETE FROM MovieCast mc WHERE mc.movie.id = :movieId AND mc.job != :job")
    void deleteByMovieIdAndJobNot(@Param("movieId") Long movieId, @Param("job") String job);
    
    boolean existsByMovieIdAndPersonIdAndJob(Long movieId, Long personId, String job);
}

// ========== 5. ENHANCED DTOs AND REQUEST MODELS ==========

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class GenreDTO {
    private Long id;
    private String name;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CountryDTO {
    private Long id;
    private String name;
    private String countryCode;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class LanguageDTO {
    private Long id;
    private String name;
    private String languageCode;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CompanyDTO {
    private Long id;
    private String name;
    private String logoPath;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CastDTO {
    private Long id;
    private Long personId;
    private String name;
    private String profilePath;
    private String characterName;
    private Integer orderIndex;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CrewDTO {
    private Long id;
    private Long personId;
    private String name;
    private String profilePath;
    private String job;
}

// Request DTOs
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CastRequest {
    @NotNull(message = "Person ID is required")
    @Min(value = 1, message = "Person ID must be positive")
    private Long personId;
    
    @NotBlank(message = "Character name is required")
    @Size(max = 255, message = "Character name must not exceed 255 characters")
    private String characterName;
    
    @Min(value = 0, message = "Order index must be non-negative")
    private Integer orderIndex;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CrewRequest {
    @NotNull(message = "Person ID is required")
    @Min(value = 1, message = "Person ID must be positive")
    private Long personId;
    
    @NotBlank(message = "Job is required")
    @Size(max = 100, message = "Job must not exceed 100 characters")
    private String job;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class BulkRelationshipRequest {
    @NotEmpty(message = "Entity IDs list cannot be empty")
    @Valid
    private List<@Min(1) Long> entityIds;
    
    private boolean replaceMode = false; // If true, replace all existing relationships
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class RelationshipStatsDTO {
    private Long genreCount;
    private Long countryCount;
    private Long languageCount;
    private Long companyCount;
    private Long castCount;
    private Long crewCount;
}

// ========== 6. EVENT SYSTEM ==========

@Data
@AllArgsConstructor
public class RelationshipChangedEvent {
    private Long movieId;
    private String relationshipType;
    private String operation; // ADD, REMOVE, BULK_ADD, BULK_REMOVE
}

@Component
@EventListener
@Slf4j
public class RelationshipEventListener {
    
    @EventListener
    @Async
    public void handleRelationshipChanged(RelationshipChangedEvent event) {
        log.info("Relationship changed: Movie {}, Type: {}, Operation: {}", 
                event.getMovieId(), event.getRelationshipType(), event.getOperation());
        
        // Here you can add additional logic like:
        // - Invalidate specific cache entries
        // - Update search indices
        // - Send notifications
        // - Update statistics
        // - Trigger recommendations recalculation
    }
}

// ========== 7. EXCEPTION HANDLING ==========

@ControllerAdvice
@Slf4j
public class RelationshipExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<String>> handleResourceNotFound(ResourceNotFoundException ex) {
        log.error("Resource not found: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error("Resource not found", ex.getMessage()));
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<String>> handleIllegalArgument(IllegalArgumentException ex) {
        log.error("Invalid argument: {}", ex.getMessage());
        return ResponseEntity.badRequest()
                .body(ApiResponse.error("Invalid argument", ex.getMessage()));
    }
    
    @ExceptionHandler(UnsupportedOperationException.class)
    public ResponseEntity<ApiResponse<String>> handleUnsupportedOperation(UnsupportedOperationException ex) {
        log.error("Unsupported operation: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED)
                .body(ApiResponse.error("Unsupported operation", ex.getMessage()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage()));
        
        log.error("Validation failed: {}", errors);
        return ResponseEntity.badRequest()
                .body(ApiResponse.error("Validation failed", errors));
    }
}

// ========== 8. CONFIGURATION AND CACHING ==========

@Configuration
@EnableCaching
public class RelationshipCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .recordStats());
        return cacheManager;
    }
}

// ========== 9. TESTING UTILITIES ==========

@TestConfiguration
public class RelationshipTestConfig {
    
    @Bean
    @Primary
    public MovieRelationshipService mockRelationshipService() {
        return Mockito.mock(MovieRelationshipService.class);
    }
}

// ========== 10. USAGE EXAMPLES WITH ENHANCED FEATURES ==========

/*
// Basic CRUD Operations
GET /api/movies/1/relationships/genres?page=0&size=10
GET /api/movies/1/relationships/cast?page=0&size=20
POST /api/movies/1/relationships/genres
Body: [1, 2, 3, 5]

DELETE /api/movies/1/relationships/genres/2

// Specialized Cast/Crew Operations
POST /api/movies/1/relationships/cast
Body: [
  {
    "personId": 123,
    "characterName": "Tony Stark",
    "orderIndex": 1
  },
  {
    "personId": 456,
    "characterName": "Pepper Potts",
    "orderIndex": 2
  }
]

POST /api/movies/1/relationships/crew
Body: [
  {
    "personId": 789,
    "job": "Director"
  },
  {
    "personId": 101112,
    "job": "Producer"
  }
]

// Bulk Operations
POST /api/movies/1/relationships/genres/bulk
Body: {
  "entityIds": [1, 2, 3, 4, 5],
  "replaceMode": true
}

DELETE /api/movies/1/relationships/genres/bulk
Body: [1, 3, 5]

// Reverse Lookup
GET /api/genres/1/movies?page=0&size=20
GET /api/persons/123/movies?job=actor&page=0&size=10
GET /api/persons/456/movies?job=director

// Statistics
GET /api/movies/1/relationships/stats
Response: {
  "success": true,
  "data": {
    "genreCount": 3,
    "countryCount": 2,
    "languageCount": 1,
    "companyCount": 5,
    "castCount": 15,
    "crewCount": 23
  }
}
*/

// ========== 11. PERFORMANCE MONITORING ==========

@Component
@Slf4j
public class RelationshipPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public RelationshipPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @EventListener
    public void monitorRelationshipOperations(RelationshipChangedEvent event) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        Counter.builder("relationship.operations")
               .tag("type", event.getRelationshipType())
               .tag("operation", event.getOperation())
               .register(meterRegistry)
               .increment();
               
        sample.stop(Timer.builder("relationship.operation.duration")
                        .tag("type", event.getRelationshipType())
                        .register(meterRegistry));
    }
}